/**
 * @description Controller to fetch related records based on custom metadata configurations.
 * This class is refactored to reduce cognitive complexity by using smaller, reusable private methods.
 * VERSION 2: Corrected dynamic SOQL binding issue.
 */
public with sharing class RelatedObjectsController {

    //================================================================================
    // Public AuraEnabled Methods
    //================================================================================

    @AuraEnabled(cacheable=true)
    public static Map<String, Object> getRelatedObjectsAndRecords() {
        Map<String, Object> relatedData = new Map<String, Object>();
        Id currentUserId = UserInfo.getUserId();

        for (Home_Page_Objects_Configuratiom__mdt config : fetchHomePageObjectConfigs(10)) {
            if (isConfigInvalid(config)) continue;

            List<String> fieldList = parseFields(config.Fields__c);
            if (fieldList.size() <= 2) continue;

            String soql = buildHomeObjectsSoql(config.Object__c, fieldList, config.Subscriber__c, currentUserId);
            List<SObject> records = executeQuery(soql, config.Object__c);

            if (records != null) {
                relatedData.put(config.MasterLabel, packageDataForResponse(fieldList, records));
            }
        }
        return relatedData;
    }

    @AuraEnabled(cacheable=true)
    public static Map<String, Object> getAllRelatedRecords(Id recordId) {
        if (recordId == null) {
            throw new AuraHandledException('Record Id is required.');
        }

        Map<String, Object> relatedData = new Map<String, Object>();
        String objectName = getSObjectNameFromId(recordId);

        for (RelatedObject__mdt config : fetchRelatedObjectConfigs(objectName)) {
            if (isConfigInvalid(config)) continue;

            List<String> fieldList = parseFields(config.Fields__c, true);
            if (fieldList.isEmpty()) continue;

            String soql = buildRelatedRecordsSoql(config.RelatedObject__c, fieldList, config.Lookup__c, recordId);
            List<SObject> records = executeQuery(soql, config.RelatedObject__c);

            if (records != null) {
                relatedData.put(config.RelatedObject__c, packageDataForResponse(fieldList, records));
            }
        }
        return relatedData;
    }

    @AuraEnabled(cacheable=true)
    public static Map<String, Object> getParentRecords(Id childRecordId) {
        if (childRecordId == null) {
            throw new AuraHandledException('Child Record Id is required.');
        }

        Map<String, Object> parentData = new Map<String, Object>();
        String childObjectName = getSObjectNameFromId(childRecordId);

        for (RelatedParentObject__mdt config : fetchRelatedParentObjectConfigs(childObjectName)) {
            if (isConfigInvalid(config)) continue;

            Id parentRecordId = getParentId(childObjectName, config.Lookup__c, childRecordId);
            if (parentRecordId == null) continue;

            List<String> fieldList = parseFields(config.Fields__c, true);
            if (fieldList.isEmpty()) continue;

            String soql = buildParentRecordSoql(config.RelatedObject__c, fieldList, parentRecordId);
            List<SObject> records = executeQuery(soql, config.RelatedObject__c);

            if (records != null) {
                parentData.put(config.RelatedObject__c, packageDataForResponse(fieldList, records));
            }
        }
        return parentData;
    }

    //================================================================================
    // Private Helper Methods - Metadata Fetching
    //================================================================================

    private static List<Home_Page_Objects_Configuratiom__mdt> fetchHomePageObjectConfigs(Integer recordLimit) {
        return [SELECT Fields__c, MasterLabel, Object__c, Subscriber__c FROM Home_Page_Objects_Configuratiom__mdt LIMIT :recordLimit];
    }

    private static List<RelatedObject__mdt> fetchRelatedObjectConfigs(String objectName) {
        return [SELECT RelatedObject__c, Fields__c, Lookup__c, MasterLabel FROM RelatedObject__mdt WHERE MasterLabel = :objectName];
    }

    private static List<RelatedParentObject__mdt> fetchRelatedParentObjectConfigs(String childObjectName) {
        return [SELECT MasterLabel, Fields__c, RelatedObject__c, Lookup__c FROM RelatedParentObject__mdt WHERE MasterLabel = :childObjectName];
    }

    //================================================================================
    // Private Helper Methods - SOQL Builders
    //================================================================================

    private static String buildHomeObjectsSoql(String objectName, List<String> fieldList, String subscriberField, Id currentUserId) {
        // FIX: Reverted to string concatenation for dynamic SOQL bind variables. This is safe for Id types.
        String whereClause = String.isNotBlank(subscriberField)
            ? subscriberField + ' = \'' + currentUserId + '\''
            : 'OwnerId = \'' + currentUserId + '\'';
        
        return 'SELECT ' + String.join(fieldList, ', ') + ' FROM ' + objectName + ' WHERE ' + whereClause + ' LIMIT 10';
    }

    private static String buildRelatedRecordsSoql(String relatedObject, List<String> fieldList, String lookupField, Id recordId) {
        // FIX: Reverted to string concatenation for dynamic SOQL.
        return 'SELECT ' + String.join(fieldList, ', ') + ' FROM ' + relatedObject + ' WHERE ' + lookupField + ' = \'' + recordId + '\' LIMIT 10';
    }

    private static String buildParentRecordSoql(String parentObject, List<String> fieldList, Id parentRecordId) {
        // FIX: Reverted to string concatenation for dynamic SOQL.
        return 'SELECT ' + String.join(fieldList, ', ') + ' FROM ' + parentObject + ' WHERE Id = \'' + parentRecordId + '\'';
    }

    //================================================================================
    // Private Helper Methods - Data Processing & Utilities
    //================================================================================

    private static List<SObject> executeQuery(String soql, String objectNameForError) {
        try {
            return Database.query(soql);
        } catch (Exception e) {
            System.debug('Error querying object: ' + objectNameForError + '. Details: ' + e.getMessage());
            return null;
        }
    }

    private static Id getParentId(String childObjectName, String lookupField, Id childRecordId) {
        // FIX: Query into a list to prevent an exception if no record is found.
        String childQuery = 'SELECT ' + lookupField + ' FROM ' + childObjectName + ' WHERE Id = \'' + childRecordId + '\'';
        List<SObject> childRecords = executeQuery(childQuery, childObjectName);

        if (childRecords != null && !childRecords.isEmpty()) {
            return (Id)childRecords[0].get(lookupField);
        }
        return null;
    }
    
    private static List<String> parseFields(String fieldsStr, Boolean ensureId) {
        List<String> fieldList = parseFields(fieldsStr);
        if (ensureId && !fieldList.contains('Id')) {
            fieldList.add(0, 'Id');
        }
        return fieldList;
    }

    private static List<String> parseFields(String fieldsStr) {
        List<String> fieldList = new List<String>();
        if (String.isBlank(fieldsStr)) return fieldList;
        for (String field : fieldsStr.split(',')) {
            String trimmedField = field.trim();
            if (String.isNotBlank(trimmedField) && !fieldList.contains(trimmedField)) {
                fieldList.add(trimmedField);
            }
        }
        return fieldList;
    }

    private static Map<String, Object> packageDataForResponse(List<String> fieldList, List<SObject> records) {
        Map<String, Object> objectData = new Map<String, Object>();
        objectData.put('fields', fieldList);
        objectData.put('records', flattenRecords(records, fieldList));
        return objectData;
    }

    private static List<Map<String, Object>> flattenRecords(List<SObject> records, List<String> fieldList) {
        List<Map<String, Object>> flatRecords = new List<Map<String, Object>>();
        for (SObject record : records) {
            Map<String, Object> flatRecord = new Map<String, Object>();
            for (String field : fieldList) {
                flatRecord.put(field, getRelationshipFieldValue(record, field));
            }
            flatRecords.add(flatRecord);
        }
        return flatRecords;
    }
    
    private static Object getRelationshipFieldValue(SObject record, String fieldName) {
        if (!fieldName.contains('.')) return record.get(fieldName);

        List<String> parts = fieldName.split('\\.');
        SObject tempObj = record;
        for (Integer i = 0; i < parts.size() - 1; i++) {
            if (tempObj == null) return null;
            tempObj = tempObj.getSObject(parts[i]);
        }
        return (tempObj != null) ? tempObj.get(parts[parts.size() - 1]) : null;
    }
    
    private static String getSObjectNameFromId(Id recordId) {
        return recordId.getSObjectType().getDescribe().getName();
    }

    //================================================================================
    // Private Helper Methods - Validation
    //================================================================================

    private static Boolean isConfigInvalid(Home_Page_Objects_Configuratiom__mdt config) {
        return String.isBlank(config.Object__c) || String.isBlank(config.Fields__c);
    }

    private static Boolean isConfigInvalid(RelatedObject__mdt config) {
        return String.isBlank(config.RelatedObject__c) || String.isBlank(config.Fields__c) || String.isBlank(config.Lookup__c);
    }

    private static Boolean isConfigInvalid(RelatedParentObject__mdt config) {
        return String.isBlank(config.RelatedObject__c) || String.isBlank(config.Fields__c) || String.isBlank(config.Lookup__c);
    }
}
