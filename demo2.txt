it('handles next page logic correctly', async () => {
    getRelatedObjectsAndRecords.mockResolvedValue(mockRelatedObjectsAndRecords);

    const element = createElement('c-a-p-m-my-records', {
        is: ApmMyRecords
    });
    document.body.appendChild(element);

    await flushPromises();

    // Simulate two next clicks
    const nextIcons = element.shadowRoot.querySelectorAll('lightning-icon[icon-name="utility:chevronright"]');
    expect(nextIcons.length).toBeGreaterThan(0);

    nextIcons.forEach(icon => {
        icon.dispatchEvent(new CustomEvent('click', {
            bubbles: true,
            composed: true
        }));
    });

    await flushPromises();
});

it('handles previous page logic correctly', async () => {
    getRelatedObjectsAndRecords.mockResolvedValue(mockRelatedObjectsAndRecords);

    const element = createElement('c-a-p-m-my-records', {
        is: ApmMyRecords
    });
    document.body.appendChild(element);

    await flushPromises();

    // Manually simulate next and then previous
    const nextIcons = element.shadowRoot.querySelectorAll('lightning-icon[icon-name="utility:chevronright"]');
    const prevIcons = element.shadowRoot.querySelectorAll('lightning-icon[icon-name="utility:chevronleft"]');

    expect(nextIcons.length).toBeGreaterThan(0);
    expect(prevIcons.length).toBeGreaterThan(0);

    nextIcons.forEach(icon => {
        icon.dispatchEvent(new CustomEvent('click', {
            bubbles: true,
            composed: true
        }));
    });

    await flushPromises();

    prevIcons.forEach(icon => {
        icon.dispatchEvent(new CustomEvent('click', {
            bubbles: true,
            composed: true
        }));
    });

    await flushPromises();
});

it('disables next and prev icons appropriately at boundaries', async () => {
    getRelatedObjectsAndRecords.mockResolvedValue(mockRelatedObjectsAndRecords);

    const element = createElement('c-a-p-m-my-records', {
        is: ApmMyRecords
    });
    document.body.appendChild(element);

    await flushPromises();

    const pagedObj = element.pagedObjects.find(obj => obj.objectName === 'Account');

    // Should be first page initially
    expect(pagedObj.isPrevDisabled).toBe(true);
    expect(pagedObj.isNextDisabled).toBe(false);

    // Manually move to last page
    element.pages.Account = pagedObj.totalPages;

    const updatedObj = element.pagedObjects.find(obj => obj.objectName === 'Account');
    expect(updatedObj.isNextDisabled).toBe(true);
    expect(updatedObj.isPrevDisabled).toBe(false);
});
