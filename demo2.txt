import { createElement } from 'lwc';
import ApmMyRecords from 'c/apmMyRecords'; // Adjusted to match JS class name. Change to 'c/aPM_MyRecords' if that is your exact component name.
import getRelatedObjectsAndRecords from '@salesforce/apex/APM_apLWC_MyRecordsController.getRelatedObjectsAndRecords';
import getRelated from '@salesforce/apex/APM_apLWC_MyRecordsController.getAllRelatedRecords';
import getRelatedParent from '@salesforce/apex/APM_apLWC_MyRecordsController.getParentRecords';

// Mock JSON data - USES YOUR EXISTING FILES
const mockRelatedObjectsAndRecords = require('./data/relatedObjectsAndRecords.json');
const mockRelated = require('./data/relatedRecords.json');
const mockParent = require('./data/parentRecords.json');

// NEW MOCK DATA FILE FOR PAGINATION - REQUIRES THE FILE FROM STEP 1
const mockPaginationData = require('./data/relatedObjectsAndRecordsWithPagination.json');


// Mock Apex - UNCHANGED
jest.mock('@salesforce/apex/APM_apLWC_MyRecordsController.getRelatedObjectsAndRecords', () => ({
    default: jest.fn()
}), { virtual: true });

jest.mock('@salesforce/apex/APM_apLWC_MyRecordsController.getAllRelatedRecords', () => ({
    default: jest.fn()
}), { virtual: true });

jest.mock('@salesforce/apex/APM_apLWC_MyRecordsController.getParentRecords', () => ({
    default: jest.fn()
}), { virtual: true });


describe('c-a-p-m-my-records', () => {
    afterEach(() => {
        while (document.body.firstChild) {
            document.body.removeChild(document.body.firstChild);
        }
        jest.clearAllMocks();
    });

    async function flushPromises() {
        // This is a microtask-based flush, which is standard for LWC Jest tests.
        return new Promise(resolve => setImmediate(resolve));
    }

    // =================================================================
    // YOUR EXISTING TESTS (UNCHANGED)
    // =================================================================
    it('renders tables for relatedData', async () => {
        getRelatedObjectsAndRecords.mockResolvedValue(mockRelatedObjectsAndRecords);

        const element = createElement('c-a-p-m-my-records', {
            is: ApmMyRecords
        });
        document.body.appendChild(element);

        await flushPromises();

        // Should render two tables (Account and Contact)
        const tables = element.shadowRoot.querySelectorAll('table.slds-table');
        expect(tables.length).toBe(2);

        // Should render record links
        const recordLinks = element.shadowRoot.querySelectorAll('a.slds-text-link');
        expect(recordLinks.length).toBe(3);
    });

    it('renders "No Records Found" when no records', async () => {
        getRelatedObjectsAndRecords.mockResolvedValue({
            EmptyObj: {
                fields: ['Id', 'Name', 'Custom_Field__c'],
                records: []
            }
        });

        const element = createElement('c-a-p-m-my-records', {
            is: ApmMyRecords
        });
        document.body.appendChild(element);

        await flushPromises();

        const noRecords = element.shadowRoot.querySelector('.no-records-container h3');
        expect(noRecords).not.toBeNull();
        expect(noRecords.textContent).toBe('No Records Found');
    });

    it('shows error message when Apex fails', async () => {
        getRelatedObjectsAndRecords.mockRejectedValue({ body: { message: 'Test error' } });

        const element = createElement('c-a-p-m-my-records', {
            is: ApmMyRecords
        });
        document.body.appendChild(element);

        await flushPromises();

        const errorMsg = element.shadowRoot.querySelector('.slds-text-color_error');
        expect(errorMsg).not.toBeNull();
        expect(errorMsg.textContent).toContain('Test error');
    });

    it('opens modal and loads related/parent records on icon click', async () => {
        getRelatedObjectsAndRecords.mockResolvedValue(mockRelatedObjectsAndRecords);
        getRelated.mockResolvedValue(mockRelated);
        getRelatedParent.mockResolvedValue(mockParent);

        const element = createElement('c-a-p-m-my-records', {
            is: ApmMyRecords
        });
        document.body.appendChild(element);

        await flushPromises();

        // Simulate click on lightning-icon for first Account record
        const icon = element.shadowRoot.querySelector('lightning-icon[data-index="0"][data-objectindex="0"]');
        expect(icon).not.toBeNull();
        icon.click();

        // Wait for both Apex calls in Promise.all to resolve
        await flushPromises();
        await flushPromises();

        // Modal should now be open
        expect(element.shadowRoot.querySelector('.slds-modal.slds-fade-in-open')).not.toBeNull();

        // Should display related/parent records in accordion
        const accordionSections = element.shadowRoot.querySelectorAll('lightning-accordion-section');
        expect(accordionSections.length).toBeGreaterThan(0);
    });

    it('shows "No Records Found" in modal accordion if no related records', async () => {
        getRelatedObjectsAndRecords.mockResolvedValue(mockRelatedObjectsAndRecords);
        getRelated.mockResolvedValue({});
        getRelatedParent.mockResolvedValue({});

        const element = createElement('c-a-p-m-my-records', {
            is: ApmMyRecords
        });
        document.body.appendChild(element);

        await flushPromises();

        const icon = element.shadowRoot.querySelector('lightning-icon[data-index="0"][data-objectindex="0"]');
        icon.click();

        await flushPromises();
        await flushPromises();
        
        const modalNoRecords = [...element.shadowRoot.querySelectorAll('p')]
            .find(p => p.textContent.includes('No Records Found'));
        expect(modalNoRecords).not.toBeNull();
        expect(modalNoRecords.textContent).toContain('No Records Found');
    });

    it('handles modal close', async () => {
        getRelatedObjectsAndRecords.mockResolvedValue(mockRelatedObjectsAndRecords);
        getRelated.mockResolvedValue(mockRelated);
        getRelatedParent.mockResolvedValue(mockParent);

        const element = createElement('c-a-p-m-my-records', {
            is: ApmMyRecords
        });
        document.body.appendChild(element);

        await flushPromises();

        const icon = element.shadowRoot.querySelector('lightning-icon[data-index="0"][data-objectindex="0"]');
        icon.click();

        await flushPromises();
        await flushPromises();

        const cancelBtn = element.shadowRoot.querySelector('button[aria-label="Cancel and close"]');
        cancelBtn.click();

        await flushPromises();
        
        expect(element.shadowRoot.querySelector('.slds-modal.slds-fade-in-open')).toBeNull();
    });


    // =================================================================
    // NEW PAGINATION TESTS TO INCREASE COVERAGE
    // =================================================================

    it('PAGINATION: initial state has prev disabled and next enabled for multi-page data', async () => {
        getRelatedObjectsAndRecords.mockResolvedValue(mockPaginationData);
        const element = createElement('c-a-p-m-my-records', { is: ApmMyRecords });
        document.body.appendChild(element);
        await flushPromises();

        const prevButton = element.shadowRoot.querySelector('button[title="Previous"]');
        const nextButton = element.shadowRoot.querySelector('button[title="Next"]');
        
        expect(prevButton.disabled).toBe(true);
        expect(nextButton.disabled).toBe(false);

        const pageIndicator = element.shadowRoot.querySelector('.slds-button-group span');
        expect(pageIndicator.textContent.trim()).toBe('1 / 2');
    });

    it('PAGINATION: navigates to the next page and updates buttons and records', async () => {
        getRelatedObjectsAndRecords.mockResolvedValue(mockPaginationData);
        const element = createElement('c-a-p-m-my-records', { is: ApmMyRecords });
        document.body.appendChild(element);
        await flushPromises();

        // Click the next icon
        element.shadowRoot.querySelector('lightning-icon[icon-name="utility:chevronright"]').click();
        await flushPromises();

        // Now on page 2
        const prevButton = element.shadowRoot.querySelector('button[title="Previous"]');
        const nextButton = element.shadowRoot.querySelector('button[title="Next"]');
        
        expect(prevButton.disabled).toBe(false);
        expect(nextButton.disabled).toBe(true); // This is the last page

        const pageIndicator = element.shadowRoot.querySelector('.slds-button-group span');
        expect(pageIndicator.textContent.trim()).toBe('2 / 2');

        // Verify records shown are for page 2 (should be 2 records)
        const recordLinks = element.shadowRoot.querySelectorAll('a.slds-text-link');
        expect(recordLinks.length).toBe(2);
        expect(recordLinks[0].textContent).toBe('Pagination Account 11');
    });

    it('PAGINATION: navigates to next page and then back to previous page', async () => {
        getRelatedObjectsAndRecords.mockResolvedValue(mockPaginationData);
        const element = createElement('c-a-p-m-my-records', { is: ApmMyRecords });
        document.body.appendChild(element);
        await flushPromises();

        // Go to page 2
        element.shadowRoot.querySelector('lightning-icon[icon-name="utility:chevronright"]').click();
        await flushPromises();

        // Go back to page 1
        element.shadowRoot.querySelector('lightning-icon[icon-name="utility:chevronleft"]').click();
        await flushPromises();

        // Check if we are back on page 1
        const prevButton = element.shadowRoot.querySelector('button[title="Previous"]');
        expect(prevButton.disabled).toBe(true);

        const pageIndicator = element.shadowRoot.querySelector('.slds-button-group span');
        expect(pageIndicator.textContent.trim()).toBe('1 / 2');

        const recordLinks = element.shadowRoot.querySelectorAll('a.slds-text-link');
        expect(recordLinks.length).toBe(10); // Page 1 has 10 records
    });

    it('PAGINATION: disables both buttons when there is only one page of data', async () => {
        // Use the original mock data which has less than 10 records per object
        getRelatedObjectsAndRecords.mockResolvedValue(mockRelatedObjectsAndRecords);
        const element = createElement('c-a-p-m-my-records', { is: ApmMyRecords });
        document.body.appendChild(element);
        await flushPromises();

        const prevButton = element.shadowRoot.querySelector('button[title="Previous"]');
        const nextButton = element.shadowRoot.querySelector('button[title="Next"]');

        expect(prevButton.disabled).toBe(true);
        expect(nextButton.disabled).toBe(true);

        const pageIndicator = element.shadowRoot.querySelector('.slds-button-group span');
        expect(pageIndicator.textContent.trim()).toBe('1 / 1');
    });
});
